<!-- -*- eval:(visual-line-mode 1) -*- -->

<div data-theme-toc="true"></div>
<div data-guild-docs="true"></div>

## Overview

In previous sections of [this guide](/start) you learn about Guild's core features. In this section, you learn how to apply Guild to your own work.

This is a conceptual guide rather than a step-by-step tutorial.

To add Guild support for your project, add a [Guild file](/docs/guildfile). In most cases, you don't need to change your code. Simply add a file to enable experiment tracking and other features.

> <span data-guild-class="callout note">Note</span> This guide applies to Python based projects. If your project uses a different language, refer to [*Languages Example*](/examples/languages). If you don't see a suitable example for your language, [ask for help](/new-topic?category=general).

## Identify the Main Module

To define a Guild operation, first identify the Python module to run. In some cases, the module is obvious. For more complex projects, it may take investigating.

If you're adding Guild support to someone else's project and don't know which module to run, consult the project documentation or ask the author for help.

The project may support more than one operation --- for example both *train* and *test*. Select the primary operation. This is usually related to training a model. You can add support for other operations over time.

For this guide, we use various main modules to illustate different configuration options. The source code for these modules is in the [`get-started` examples directory](https://github.com/guildai/guildai/tree/master/examples/get-started).

## Use a Virtual Environment

Even if you don't plan to use a virtual environment for your work, it's a good idea to create a new, empty virtual environment when adding Guild support. As you run your project, you discover missing Python modules. Install the applicable Python packages using `pip` and add them to `requirements.txt`. With a correct `requirements.txt` file, you can easily recreate a working virtual environment. So can others!

As you [learned earlier](/start/classifier#create-a-guild-environment), Guild works with any virtual environment, including those created with [conda](https://docs.conda.io/), [virtualenv](https://virtualenv.pypa.io), or Python's [venv](https://docs.python.org/library/venv.html) module.

Here's a simple way to create a project-local virtual environment using Python's built-in `venv` module (Python 3 only):

``` command
python -m venv venv
```

You can alternatively use [`guild init`](/commands/init) to create a virtual environment. This method uses virtualenv. To ensure that you create an empty environment, use the `--no-reqs` option.

``` command
guild init --no-reqs
```

Remember to activate your environment. When you open a new terminal, activate the environment in that terminal as well.

For POSIX shells:

``` command
source venv/bin/activate
```

For Windows:

``` command
venv\Scripts\activate.bat
```

In the activated environment, ensure that your environment uses the latest version of `pip`:

``` command
pip install --upgrade pip
```

## Run Without Guild

Before using Guild, run your operation directly with Python. This step resolves project related issues before introducing Guild.

Here's an example of running a module implemented in `mnist_mlp.py`:

``` command
python -m mnist_mlp
```

Note the use of `-m` in the command. When developing Guild files, use `-m` to run Python modules. Don't run scripts directly. It's important to understand Python module structure, which Distinguishes *Python system paths* from Python *packages*.

If the module is located in a subdirectory, determine if the subdirectory is a Python package. If the subdirectory contains a file named `__init__.py` it's a Python *package*. If it doesn't contain `__init__.py`, it's a *subdirectory path*.

Subdirectory paths must be included in the Python path when you run the module. If you're running a POSIX shell, you can include the path in the Python command as the environment variable `PYTHONPATH`. For example, if the module is located in a `src` (non-package) subdirectory, you can run:

``` command
PYTHONPATH=src python -m mnist_mlp
```

You can alternatively export `PYTHONPATH` once for the terminal session:

``` command
export PYTHONPATH=src
```

If you're running Windows, define `PYTHONPATH` using `set`:

``` command
set PYTHONPATH=%PYTHONPATH%;src
```

If the subdirectory is a Python package --- i.e. it contains `__init__.py` --- include the package in the module spec. For example, if `mnist_mlp.py` is located in subdirectory `models` alongside `__init__.py`, run it using:

``` command
python -m models.mnist_mlp
```

When you run the main module, if you get the error `No module named ...`, verify that both `PYTHONPATH` and the module spec are correct.

### Install Required Packages

When you run the main module in an activate empty virtual environment (recommended) you will likely see an error message like this:

``` output
Traceback (most recent call last):
  File "/usr/lib/python3.6/runpy.py", line 183, in _run_module_as_main
    mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
  File "/usr/lib/python3.6/runpy.py", line 109, in _get_module_details
    __import__(pkg_name)
  File ".../mnist_mlp.py", line 10, in <module>
    import keras
ModuleNotFoundError: No module named 'keras'
```

In this case, use `pip` to install required packages in the virtual environment.

``` command
pip install keras
```

When you install a missing package, add that package to `requirements.txt`. This lets you install required packages in new environments and communicates those requirements to others.

> <span data-guild-class="callout tip">Tip</span> On POSIX systems, you can use <code>echo <em>PACKAGE</em> >> requirements.txt</code> from the command line to add *`PACKAGE`* to `requirements.txt`.

Continue running the main module, installing required packages and adding them to `requirements.txt`. If there are other issues with the project code, resolve those before continuing.

## 10 Second Rule

The work of automated, reproducible machine learning is iterative. You make a change, run something, and see how it works. Delays add up quickly and distract you from your work. To speed your progress and improve focus, we recommend following the *10 second rule*:

> *Configure your operations to take less than 10 seconds.*

This rule is an adaptation from [*How to do machine learning efficiently*](https://medium.com/hackernoon/doing-machine-learning-efficiently-8ba9d9bc679d) by Radek Osmulski.

If an operation takes more than 10 seconds, consider ways to reduce its execution time. In most cases, this is a matter of reducing training epochs, steps, or procssed data records. The goal is to run the operation end-to-end as quickly as possible while executing same code path.

When you implement the 10 second rule, model performance suffers. Consider this a *development mode* that can be turned on and off. Run things quickly during development. When it's time to measure real performance, disable development mode and run full workloads.

Consider [`mnist_mlp.py`](https://github.com/guildai/guildai/blob/master/examples/get-started/mnist_mlp.py). By default, the model learns over 20 epochs. This takes several minutes.

To reduce operation run time, we can change the epoch count to 1. But rather than change the value directly, we *add lines* that change the value whenever a flag is set.

<div data-guild-github-select="21-22">

https://github.com/guildai/guildai/blob/master/examples/get-started/mnist_mlp_10sec.py#L22
</div>

With this change, the time to run the operation goes from several minutes to several seconds.

We can go further and reduce the number of train and test examples when the flag is set.

<div data-guild-github-select="33-37">

https://github.com/guildai/guildai/blob/master/examples/get-started/mnist_mlp_10sec.py#L35
</div>

With this change, the operation just over a second --- about as long as it takes to read the MNIST examples.

Why bother with a 10 second rule? If you're skeptical of this idea, skip it for now. But pay attention to the time you spend waiting for non-essential computation. Notice what happens to your attention after even 20 seconds of waiting. Many of us are tempted to use this downtime for productive work like checking news or browsing r/MachineLearning. If you feel these distractions slow your development, return to this section and try the suggestions.

Use these guidelines when considering changes for the 10 second rule:

- Remember that you are sacrificing model performance to achieve short execution times. *Don't worry when model accuracy plummets --- this is expected.*

- Avoid modifying existing lines of code. *Only add new lines.* This minimizes risk, highlights the changes, and makes it easier to remove the changes later if you want to.

- Use a single global variable to enable and disable the 10 second rule. Define the variable at the top of the module to make it easier to spot.

- Denote your changes clearly. This is usually the case when you use a variable like `_10sec` to conditionally apply changes. If you take a different approach, use clear comments as needed.

## Add a Guild File

It's time to add Guild support by adding `guild.yml` to your project!

Start with a single operation. Here's an example that runs the `mnist_mlp` module:

``` yaml
train:
  description: Train MLP based MNIST classifier
  main: mnist_mlp
```

If your main module is in a subdirectory, include that subdirectory as a path prefix in the format <code><em>PATH</em>/<em>MODULE</em></code>. For example, if your module is `mnist_mlp` and located in a `src` project subdirectory, use:

``` yaml
train:
  main: src/mnist_mlp
```

If your main module is in a Python package, include the package as you do when running with Python directly. For example, if your module is `mnist_mlp` and located in a `models` Python package (a project subdirectory containing `__init__.py`), use:

``` yaml
train:
  main: models.mnist_mlp
```



## Test Operation Source Code

Before running `train`, verify that Guild copies the correct operation source code.

From the project directory, use [`guild run`] with the `--test-sourcecode` option:

``` command
guild run --test-sourcecode
```

> <span data-guild-class="callout note">Note</span> You don't need to specify an operation for [`guild run`](/commands/run) because your Guild file contains only one operation. With more than one operation, you need to specify the operation name or designate one of the operations as default using the `default` attribute.

Note the list of files under **Selected for copy** in the output. This list should include all of the source code files required for your operation.

> <span data-guild-class="callout note">Important</span> If there are missing source code files, your operation will not run correctly. Guild is careful to isolate runs from your project source code. This prevents changes to your project source code code from affecting the operation run. It also ensures that the run has a record of exactly what is run.

Guild applies default rules to detect likely source code files. Guild uses safeguards to avoid copying too many files or files that are too big. If Guild excludes files due to safe guards, it logs a warning message.

You can change Guild's default source code copy rules by defining the `sourcecode` operation attribute.

There are four common reasons for defining operation `sourcecode`:

- Guild generates warnings about large files or too many files
- Guild is not copying some required files
- Your project has a directory with thousands of files, which causes Guild to take too much time processing source code rules
- You want to explicitly define `sourecode` rather than rely on Guild's implicit behavior

For examples of `sourcecode` specs, see [*Guild File Cheatsheet*](/cheatsheets/guildfile#source-code).

<!--

## Understand the Operation Interface

When you run the operation, consider its *interface*. The interface consists of operations *inputs* and *outputs*.

Operation inputs:

- Settings related to model architecture and related algorithms --- these are referred to as *hyperparameters*
- Other settings used by the script such as file locations, database credentials, etc.
- Required files

Operation outputs:

- Generated files
- Logged metrics --- these are referred to as *scalars*

The sections below help you identify the operation interface. With this information you later [define the operation](#define-the-operation).

### How are operation settings specified?

Python based operations are configured in various ways:

- Global variables
- Environment variables
- Command line arguments
- Configuration files
- In-place values

Guild supports each of these methods except the last. In-place values are not easily or safely modified and should be avoided.

#### Global variables

The use of global variables is perhaps the most popular method for defining operation settings.

Most Keras examples use this method. Consider [`mnist_mlp.py`](https://raw.githubusercontent.com/guildai/guildai/master/examples/use-guild/mnist_mlp.py). This module defines three global variables:

https://github.com/guildai/guildai/blob/master/examples/use-guild/mnist_mlp.py#L16-L18

Two of these variables are hyperparameters: *`batch_size`* and *`epochs`*. To change these, you edit the source code. It's time consuming to try different hyperparameters.

Because this method is so popular, Guild lets you run this script with different values for these hyperparameters.

``` command
guild run mnist_mlp.py batch_size=512 epochs=10
```

If your script uses global variables, you can use Guild to configure


#### Environment variables

#### Command line arguments

#### Configuration files

#### In-place values


### What input files does the operation require?

### What output files does the operation generate?

### What metrics does the operation log?



## Define the Operation

Define the


-->
